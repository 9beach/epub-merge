#!/bin/bash

set -euo pipefail

readonly EPUB_META_LABEL_LANG=${EPUB_META_LABEL_LANG:-$LANG}
readonly DEBUG=${DEBUG:-}  # Debug output toggle.

quiet_mode=""              # Suppress non-critical logs.
edit_mode=""               # If not set, show metadata; if set, modify.
fix_cover_given=""         # Fix cover if set
do_not_sort_given=""       # Do not sort attributes when displaying
single_line_given=""       # Display each attribute value in a single line
new_cover_path=""          # Set new cover if set
alt_cover_path=""          # Replace existing cover if set
out_cover_path=""          # Extract cover if set

epub_file=""               # Input EPUB file path.
opf_file=""                # Input OPF file path (if given).
epub_opf=""                # Path to OPF inside EPUB.
temp_dir=""                # Temporary working directory.
indent=""                  # Indentation detected before </metadata>.
removing_filter=""         # Regex to remove old tags before insertion.
color_filter=""            # Regex for highlighting changed fields in output.
readonly real_lf=$'\037'   # Internal field separator for XML line handling.

readonly removing="<removed>"       # Marker for deleting a field.
readonly opf_header="header"        # Original OPF header path
readonly new_opf_header="newhr"     # Modified OPF header path
readonly opf_footer="footer"        # OPF footer path

iconv_has_utf_8_mac="$(iconv -l | grep "UTF-8-MAC" || true)"
readonly iconv_has_utf_8_mac

# --- From args

new_title=""
new_author=""
new_translator=""
new_publisher=""
new_subject=""
new_language=""
new_description=""
new_isbn=""
new_rights=""
new_published=""
new_modified=""

# --- Label translations

if [[ "$EPUB_META_LABEL_LANG" == ko* ]]; then
	readonly label_title="제목"
	readonly label_author="작가"
	readonly label_translator="번역"
	readonly label_subject="주제"
	readonly label_publisher="출판사"
	readonly label_language="언어"
	readonly label_description="설명"
	readonly label_published="출판일"
	readonly label_modified="수정일"
	readonly label_created="작성일"
	readonly label_rights="권리"
	readonly label_isbn="도서번호"
else
	readonly label_title="Title"
	readonly label_author="Author"
	readonly label_translator="Translator"
	readonly label_subject="Subject"
	readonly label_publisher="Publisher"
	readonly label_language="Language"
	readonly label_description="Description"
	readonly label_published="Published"
	readonly label_modified="Modified"
	readonly label_created="Created"
	readonly label_rights="Rights"
	readonly label_isbn="ISBN"
fi

# --- Utility functions

show_usage() {
	# Print usage and help message to stderr.
	cat >&2 << 'EOF'
epub-meta -- read and edit metadata in an ePUB or OPF file

Usage:
  epub-meta [options] {epub-file | opf-file}

Options:
  -a AUTHOR      Set author(s). Multiple authors separated by "//".
                 Format: "Name" or "Name--Sort Name"
                 (e.g., "Bob Marley//Tom Waits--Waits, Tom")
  -c FILE        Set new cover image from FILE
  -C FILE        Replace cover image from FILE
  -d DESC        Set description
  -f             Auto-fix cover image configuration
  -i ISBN        Set ISBN
  -l LANG        Set language (e.g., en, ko)
  -m DATE        Set modification date
  -O             Do not sort attributes when displaying metadata
  -p PUBLISHER   Set publisher
  -q             Quiet mode (suppress progress messages)
  -r TRANSLATOR  Set translator(s) (same format as -a)
  -s SUBJECT     Set subject(s) (multiple separated by '//')
  -S PATH        Extract cover image to PATH (extension auto-added)
  -t TITLE       Set title
  -u DATE        Set publication date (e.g., "2016-07-31")
  -x RIGHTS      Set rights/copyright info
  -h             Show this help message
  -1             Display each attribute value in a single line
                 (replace newlines with \n)

Notes:
  - Use empty string ("") to remove a metadata field.
  - Without options, displays current metadata.
EOF
	exit 1
}

cleanup() {
	# Remove temporary working directory if it exists.
	if [[ -d "${temp_dir:-}" ]]; then
		rm -rf "$temp_dir"
	fi
}

log() {
	# Print gray log messages unless quiet_mode is set.
	if [[ -z "$quiet_mode" ]]; then
		printf '\033[90m%s\033[0m\n' "$*" >&2
	fi
}

debug() {
	# Print blue debug messages when DEBUG is enabled.
	if [[ -n "$DEBUG" ]]; then
		printf "\033[34m[DEBUG] #${BASH_LINENO[1]} %s\033[0m\n" "$*" >&2
	fi
}

debug_var() {
	# Print blue debug messages of a variable when DEBUG is enabled.
	# e.g., debug_var variable_name_without_dollar_prefix
	debug "$1=\"${!1}\""
}

error() {
	# Print red error message and exit.
	printf "\033[31mError (epub-meta): %s\033[0m\n" "$*" >&2
	exit 1
}

check_file_type() {
	# Quickly checks file type (XML or ZIP) by examining the first few
	# bytes.
	local file="$1" header_bytes
	readonly zip_magic=$'PK\x03\x04'
	readonly utf8_bom=$'\xEF\xBB\xBF'
	readonly xml_start='<?xml'
	readonly opf_start='<pack'
	header_bytes=$(head -c 4 "$1")

	if [[ "$header_bytes" == "$zip_magic" ]]; then
		epub_file="$(realpath "$1")"
		readonly epub_file
		return 0
	fi

	header_bytes=$(head -c 13 "$file")
	header_bytes="${header_bytes#$utf8_bom}"
	if [[ "$header_bytes" == "$xml_start"* \
			|| "$header_bytes" == "$opf_start"* ]]; then
		opf_file="$(realpath "$1")"
		readonly opf_file
		return 0
	fi

	error "$(basename "$1"): not an EPUB or OPF file"
}

parse_args() {
	while getopts "t:a:r:p:s:l:d:i:x:c:C:S:u:m:1qhfO" opt; do
		# shellcheck disable=SC2034
		case $opt in
			t) new_title="${OPTARG:-$removing}"; edit_mode=1 ;;
			a) new_author="${OPTARG:-$removing}"; edit_mode=1 ;;
			c) new_cover_path="$(realpath "${OPTARG}")" ;;
			C) alt_cover_path="$(realpath "${OPTARG}")" ;;
			f) fix_cover_given=1 ;;
			O) do_not_sort_given=1 ;;
			S) out_cover_path="$(realpath "$(dirname \
				"${OPTARG}")")/$(basename "${OPTARG}")" ;;
			q) quiet_mode=1 ;;
			r) new_translator="${OPTARG:-$removing}"; edit_mode=1 ;;
			p) new_publisher="${OPTARG:-$removing}"; edit_mode=1 ;;
			s) new_subject="${OPTARG:-$removing}"; edit_mode=1 ;;
			l) new_language="${OPTARG:-$removing}"; edit_mode=1 ;;
			d) new_description="${OPTARG:-$removing}"
			   edit_mode=1 ;;
			i) new_isbn="${OPTARG:-$removing}"; edit_mode=1 ;;
			x) new_rights="${OPTARG:-$removing}"; edit_mode=1 ;;
			u) new_published="${OPTARG:-$removing}"; edit_mode=1 ;;
			m) new_modified="${OPTARG:-$removing}"; edit_mode=1 ;;
			1) single_line_given=1 ;;
			h) show_usage ;;
			\?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
			:) echo "Option -$OPTARG requires an argument." >&2
			   exit 1 ;;
		esac
	done

	readonly new_title new_author new_cover_path alt_cover_path \
		fix_cover_given out_cover_path quiet_mode new_translator \
		new_publisher new_subject new_language new_description \
		edit_mode new_isbn new_rights new_published new_modified
}

validate_args() {
	if [[ $# -ne 1 ]]; then
		show_usage
	fi

	check_file_type "$1"

	if [[ -n "$epub_file" ]]; then
		epub_opf="$(unzip -p "$epub_file" META-INF/container.xml \
			| sed -n "s#.*full-path=.\([^\"']*\).*#\\1#p")"

		if [[ -z "$epub_opf" ]]; then
			error "OPF file not found."
		fi
	fi

	if [[ -z "$epub_file" ]]; then
		if [[ -n "$fix_cover_given" || -n "$new_cover_path" \
			|| -n "$out_cover_path" || -n "$alt_cover_path" ]]; then
			error 'cover-related options cannot be used with OPF'
		fi
	fi

	if [[ ( -n "$new_cover_path" || -n "$alt_cover_path" ) \
		&& -n "$fix_cover_given" ]]; then
		error "Option '-f' cannot be used with '-c' or '-C'"
	fi

	if [[ -n "$new_cover_path" && -n "$alt_cover_path" ]]; then
		error "Option '-c' and '-C' cannot be used together"
	fi
}

# --- XML handling helpers

escape_xml() {
	# Escape special XML characters and control chars.
	# If input contains CDATA, keep it intact but flatten newlines to '\r'.
	input="$1"

	# If CDATA, return as-is
	if [[ "$input" =~ \<!\[CDATA\[ ]]; then
		# Make CDATA one line, later recover with `tr '\r' '\n'`
		printf '%s' "$input" | tr '\n' '\r'
		return
	fi

	# Otherwise, escape XML special chars and control characters
	printf '%s' "$input" \
		| tr '\n' '\r' \
		| sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' \
			-e 's/"/\&quot;/g' -e "s/'/\\&apos;/g" -e 's/#/\#/g'
		# `#` is delimeter of `sed` in the code.
}

unescape_xml() {
	sed -E -e 's/&#xD;//g' -e 's/&#13;//g' -e 's/&#xA;/\n/g' \
		-e 's/&#10;/\n/g' -e 's/&#x9;/\t/g' -e 's/&#9;/\t/g' \
		-e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&quot;/"/g' \
		-e 's/&nbsp;/ /g' -e "s/&apos;/'/g" -e 's/&#39;/'"'"'/g' \
		-e 's/&#x00A9;/©/g' -e 's/&#x27;/'"'"'/g' -e 's/&amp;/\&/g'
}

join_lines() {
	# Replace '\n' with unit separator for line-safe processing.
	tr '\n' $real_lf < "${1:-/dev/stdin}" | tr -d '\r'
}

split_real_lf() {
	# Restore line structure
	tr $real_lf '\n' < "${1:-/dev/stdin}"
}

split_xml_elements() {
	# Convert self-closing <dc:*> tags to open-close, and place each
	# element (open/close) on its own line.
	tr -d '\r' | tr '\n' $real_lf | sed -E "$sed_split_xml_elements"
}

sed_split_xml_elements="
s#<dc:(title|publisher|subject|creator|description|rights|language\
|contributor|date|identifier)([[:blank:]]*|[[:blank:]]+[^>]*)/>\
#<dc:\1\2></dc:\1>#g;

s#(</dc:title[^>]*>|</dc:publisher[^>]*>|</dc:subject[^>]*>|</dc:creator[^>]*>\
|</dc:description[^>]*>|</dc:rights[^>]*>|</dc:language[^>]*>\
|</dc:contributor[^>]*>|</dc:identifier[^>]*>|</dc:date[^>]*>)#&\n#g;

s#<dc:(title|publisher|subject|creator|description|rights|language\
|contributor|identifier|date)#\n&#g
"
readonly sed_split_xml_elements

# --- Metadata edit

echo_multi_tags() {
	# Create multi tags from 'display_name--sort_name' format and
	# multi-entry (// separated).
	local new_content="$1"
	local tags=""
	local content_lines
	content_lines=$(echo -E "$new_content" \
		| sed -E 's#[[:blank:]]*//[[:blank:]]*#\n#g')

	while IFS= read -r name; do
		if [[ "$name" == *'--'* ]]; then
			display_name="${name%%--*}"
			sort_name="${name##*--}"

			tags+="$indent$indent\n<${element}"
			tags+="${attr_string} opf:file-as=\"$sort_name\">"
			tags+="$display_name</$element>${real_lf}"
		else
			tags+="$indent$indent\n<${element}"
			tags+="${attr_string}>$name</$element>${real_lf}"
		fi
	done <<< "$content_lines"

	echo -e "${tags}"
}

echo_new_tags() {
	# Create dc elements and print them.
	local element="dc:$1" tag
	local attr="${2:-}" value="${3:-}"
	local content="new_${4:-$1}"
	local attr_string="" new_content="${!content}"

	if [[ -z "${new_content}" || "$new_content" == "$removing" ]]; then
		return 0
	fi

	if [[ -n "$attr" && -n "$value" ]]; then
		attr_string=" ${attr}=\"${value}\""
		attr_string+=" xmlns:opf=\"http://www.idpf.org/2007/opf\""
	fi
	if [[ "$new_content" == "$removing" ]]; then
		return
	fi

	new_content="$(escape_xml "$new_content")"
	if [[ -n "${SUPPORT_MULTI_VALUES:-}" ]]; then
		echo_multi_tags "$new_content"
	else
		tag="$indent$indent\n<${element}${attr_string}>"
		tag+="${new_content}</${element}>\n$real_lf"
		echo -e "$tag"
	fi
}

to_nfc() {
	# Convert to NFC encoding
	if [ -n "$iconv_has_utf_8_mac" ]; then
		iconv -f UTF-8-MAC -t UTF-8 ${1:+"$1"}
	else
		cat ${1:+"$1"}
	fi
}

format_opf() {
	# Rebuild the final OPF file:
	#   - combine modified header and untouched footer,
	#   - normalize line breaks,
	#   - strip blank lines.
	cat "$new_opf_header" "$opf_footer" \
		| tr -d '\n' \
		| split_real_lf \
		| tr '\r' '\n' \
		| grep -Ev '^[[:blank:]]+$'
}

build_element_filters() {
	# Build filters for colorizing modified attributes and removing
	# old values
	local element="$1" content="new_${4:-$1}"
	local new_content="${!content}" label="label_${4:-$1}"
	local attr="${2:-}" value="${3:-}" value_esc

	if [[ -n "$new_content" ]]; then
		# Build regex pattern for matching dc:* element with
		# optional attribute
		local attr_pattern=""
		if [[ -n "$attr" && -n "$value" ]]; then
			value_esc=$(printf '%s' "$value" \
				| sed 's/["\]/\\&/g')
			attr_pattern="[^>]*${attr}=[\"']${value_esc}[\"']"
		fi

		removing_filter+="<dc:${element}${attr_pattern}[^>]*>|"
		color_filter+="^${!label}:.*|"
	fi
}

build_all_filters() {
	# These are used to remove specific XML elements and format output
	# messages.
	#
	# Example removing_filter: "<dc:publisher[^>]*>|<dc:subject[^>]*>"
	# Example color_filter: "Publisher:.*|Subject:.*|Title:.*"
	build_element_filters title
	if [[ -n "$new_author" ]]; then
		removing_filter+="<dc:creator[[:blank:]]*>|"
	fi
	build_element_filters creator opf:role aut author
	build_element_filters creator opf:role trl translator
	build_element_filters translator opf:role trl translator
	build_element_filters contributor opf:role trl translator
	build_element_filters publisher
	build_element_filters subject
	build_element_filters language
	build_element_filters description
	build_element_filters identifier opf:scheme ISBN isbn
	build_element_filters rights
	build_element_filters date opf:event publication published
	build_element_filters date opf:event modification modified
	if [[ -n "$new_modified" ]]; then
		removing_filter+="<dc:date[[:blank:]]*>|"
	fi

	removing_filter="${removing_filter%?}"
	color_filter="${color_filter%?}"
}

# --- Start main routine

trap 'printf "\033[31mError ($(basename "$0")): at line '\
'$LINENO: $BASH_COMMAND\033[0m\n" >&2; cleanup' ERR INT TERM

trap cleanup EXIT

parse_args "$@"
shift $((OPTIND-1))

validate_args "$@"

# --- Read metadata

readonly r_matching="(.*)(</dc:.*)"
readonly sed_show_tags="
/<dc:[^>]*>.*[^[:blank:]].*<\\/dc:/I {
s#(<dc:title[^>]*>)${r_matching}#01${label_title}: \\2#
s#(<[^>]*opf:role=[\"']trl[\"'][^>]*>)${r_matching}#06${label_translator}: \\2#
s#(<dc:subject[^>]*>)${r_matching}#08${label_subject}: \\2#
s#(<dc:description[^>]*>)${r_matching}#09${label_description}: \\2#
s#(<dc:publisher[^>]*>)${r_matching}#10${label_publisher}: \\2#
s#(<dc:date[^>]*publication[^>]*>)${r_matching}#12${label_published}: \\2#
s#(<dc:date[^>]*modification[^>]*>)${r_matching}#13${label_modified}: \\2#
s#(<dc:date[^>]*>)${r_matching}#14${label_created}: \\2#
s#(<dc:language[^>]*>)${r_matching}#25${label_language}: \\2#
s#(<dc:rights[^>]*>)${r_matching}#27${label_rights}: \\2#
s#(<[^>]*opf:scheme=.ISBN[^>]*>)${r_matching}#28${label_isbn}: \\2#
s#<[^>]*opf:role=[\"']trl[\"'][^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*>\
${r_matching}#06${label_translator}: \\2 [\\1]#
s#<[^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*opf:role=[\"']trl[\"'][^>]*[^>]*>\
${r_matching}#06${label_translator}: \\2 [\\1]#
s#<[^>]*opf:role=[\"']aut[\"'][^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*>\
${r_matching}#05${label_author}: \\2 [\\1]#
s#<[^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*opf:role=[\"']aut[\"'][^>]*[^>]*>\
${r_matching}#05${label_author}: \\2 [\\1]#
s#(<dc:creator[^>]*>)${r_matching}#05${label_author}: \\2#
p
}"

show_tags() {
	# Parse OPF XML and output readable metadata (title, author, etc.)
	# Supports Korean or English labels. Filters and cleans XML tags.
	if [[ "$do_not_sort_given" -eq 1 ]]; then
		sed -nE "$sed_show_tags" ${1:+"$1"} \
			| grep -v "<dc:" \
			| sed -E "s#^..##; s:^(.*) \[Unknown\]$:\1:" \
			| unescape_xml
	else
		sed -nE "$sed_show_tags" ${1:+"$1"} \
			| grep -v "<dc:" \
			| sort -V \
			| sed -E "s#^..##; s:^(.*) \[Unknown\]$:\1:" \
			| unescape_xml
	fi
}

# No edit option, then show tags and exit.
if [[ -z "$edit_mode" && -z "$fix_cover_given" && -z "$out_cover_path" \
		&& -z "$new_cover_path" && -z "$alt_cover_path" ]]; then
	if [[ -z "$opf_file" ]]; then
		unzip -p "$epub_file" "$epub_opf"
	else
		cat "$opf_file"
	fi \
	| split_xml_elements | show_tags \
	| \
	if [[ "$single_line_given" -eq 1 ]]; then
		sed "s#$real_lf#\\\\n#g"
	else
		tr $real_lf '\n'
	fi

	exit 0
fi

# --- Edit metadata

build_all_filters

temp_dir=$(mktemp -d)
readonly temp_dir

cd "$temp_dir"

if [[ -n "$opf_file" ]]; then
	epub_opf="$temp_dir/.opf"
	join_lines "$opf_file" > "$epub_opf"
else
	mkdir -p "$(dirname "$epub_opf")"
	# shellcheck disable=SC2094
	unzip -p "$epub_file" "$epub_opf" | join_lines > "$epub_opf"
fi

indent="$(grep -m 1 -o "[[:blank:]]*</metadata>" "$epub_opf" \
	| sed -E "s#</metadata>##")"
readonly indent

# Before '  </metadata>': <?xml... -> $opf_header
sed -E 's#[[:blank:]]*</metadata>.*##' "$epub_opf" \
	| split_xml_elements \
	> "$opf_header"

# From '  </metadata>': </metadata>...</package> -> $opf_footer
sed -E 's#^.*[^[:blank:]]([[:blank:]]*</metadata>.*)#\1#' "$epub_opf" \
	> "$opf_footer"

if [[ -n "$edit_mode" ]]; then
	# Remove elements to be replaced
	grep -E -v "$removing_filter" "$opf_header" || true

	# Print new elements
	{
		echo_new_tags title
		SUPPORT_MULTI_VALUES=1 echo_new_tags creator opf:role aut author
		SUPPORT_MULTI_VALUES=1 echo_new_tags creator \
			opf:role trl translator
		SUPPORT_MULTI_VALUES=1 echo_new_tags subject subject
		echo_new_tags publisher
		echo_new_tags date opf:event publication published
		echo_new_tags date opf:event modification modified
		echo_new_tags rights
		echo_new_tags identifier opf:scheme ISBN isbn
		echo_new_tags description
		echo_new_tags language
	} | to_nfc
else
	cat "$opf_header"
fi > "$new_opf_header"

if [[ -z "$quiet_mode" && -n "$edit_mode" ]]; then
	show_tags "$new_opf_header" \
		| sed -E "s/$color_filter/\x1b[32m&\x1b[0m/g" \
		| split_real_lf | tr '\r' '\n' >&2
fi

if [[ -z "$opf_file" ]]; then
	format_opf > "$epub_opf"
	zip -q -Xr9D "$epub_file" "$epub_opf"
else
	format_opf > "$opf_file"
fi

if [[ -z "$fix_cover_given" && -z "$out_cover_path" && -z "$new_cover_path" \
		&& -z "$alt_cover_path" ]]; then
	exit
fi

# --- Functions for handling covers
#
if [[ "$OSTYPE" == "darwin"* ]]; then
	sed_i() {
		sed -i '' "$@"
	}
else
	sed_i() {
		sed -i "$@"
	}
fi

get_media_type() {
	# Get MIME type from file extension
	case "${1##*.}" in
		jpg|jpeg) echo "image/jpeg" ;;
		png)      echo "image/png" ;;
		gif)      echo "image/gif" ;;
		svg)      echo "image/svg+xml" ;;
		webp)     echo "image/webp" ;;
		avif)     echo "image/avif" ;;
		*)        echo "application/octet-stream" ;;
	esac
}

change_cover_id() {
	# Add cover meta: <meta content="cover-id" name="cover"/>
	# Add properties="cover-image" to cover-id manifest item
	local id="$1"
	local sed_cover_meta_replace="s|<meta[^>]*name=[\"\x27]cover[\"\x27]"
	sed_cover_meta_replace+="[^>]*>|<meta content=\"$id\" name=\"cover\"/>|"
	local echo_cover_meta="${indent}${indent}<meta content=\"$id\" "
	echo_cover_meta+="name=\"cover\"/>${real_lf}"

	if [[ -n "$cover_meta_found" ]]; then
		sed_i "$sed_cover_meta_replace" "$new_opf_header"
	else
		echo "$echo_cover_meta" >> "$new_opf_header"
		cover_meta_found=1
	fi

	local sed_cover_properties_add="s#<item.*id=[\"']$id[\"']#& "
	sed_cover_properties_add+="properties=\"cover-image\"#"
	if [[ "$epub_version" != "2.0" ]]; then
		sed -E -e 's/properties="cover-image"//g' \
			-e "$sed_cover_properties_add" "$opf_footer" \
			> "$opf_footer".new \
			&& mv -f "$opf_footer".new "$opf_footer"
	fi
}

find_cover_id_of_html() {
	# Get id of image in html ($2) from OPF ($1)
	# find_cover_id_of_html "OEBPS/content.opf" "Text/cover.html"

	local opf_path="$1"
	local relative_html_path="$2"

	# Get directory of OPF file
	local opf_dir
	opf_dir=$(dirname "$opf_path")

	# Construct full path to HTML file
	local html_path="${opf_dir}/${relative_html_path}"

	# Extract first image filename from HTML (e.g., "cover.jpg")
	local img_filename
	img_filename=$(grep -om1 '<img[^>]*src=["'"'"'][^"'"'"']*["'"'"']' \
			"$html_path" \
		| sed -E 's/.*src=["'"'"']([^"'"'"']*)["'"'"'].*/\1/' \
		| xargs basename)

	# Find <item> in OPF whose href ends with the image filename
	local item_line
	local grep_cover='<item[^>]*href=["'"'"'][^"'"'"']*'
	grep_cover+="$img_filename"'["'"'"'][^>]*>'
	item_line=$(grep -om1 "$grep_cover" "$opf_path" | head -n1)

	# Extract id and href from the <item> tag
	local id href
	id=$(echo "$item_line" \
		| sed -E 's/.*id=["'"'"']([^"'"'"']*)["'"'"'].*/\1/')
	href=$(echo "$item_line" \
		| sed -E 's/.*href=["'"'"']([^"'"'"']*)["'"'"'].*/\1/')

	# Output: id<TAB>href
	echo -e "${id}\t${href}"
}

# --- Handle covers

# --- Process '-c' option

epub_version="$(grep -om1 'package[^>]*version="[0-9.]*"' "$opf_header" \
	| grep -om1 'version=.[0-9.]*.' | cut -d'"' -f2)"
readonly epub_version

cover_meta_found=""
if grep -qom1 "<meta[^>]*name=.cover[\"'][^>]*>" "$epub_opf"; then
	cover_meta_found=1
fi

if [[ -n "$new_cover_path" ]]; then
	new_id="cover-$(date +%s)"
	new_ext="$(echo "${new_cover_path##*.}" | tr '[:upper:]' '[:lower:]')"
	epub_cover_path="$(dirname "$epub_opf")/$new_id.$new_ext"
	new_type="$(get_media_type "cover.$new_ext")"
	cp "$new_cover_path" "$epub_cover_path"

	item="<item href=\"$new_id.$new_ext\" id=\"$new_id\" "
	item+="media-type=\"$new_type\"/>"
	sed_i "s#<manifest[^>]*>#&$real_lf$indent$indent$item#" "$opf_footer"

	change_cover_id "$new_id"

	format_opf > "$epub_opf"
	zip -q -Xr9D "$epub_file" "$epub_cover_path" "$epub_opf"

	log "Successfully set new image as cover: $epub_cover_path"

	if [[ -z "$fix_cover_given" && -z "$out_cover_path" \
			&& -z "$alt_cover_path" ]]; then
		exit
	fi
fi

# --- Functions and variables for '-C', '-f', and '-S' options

readonly cover_opf="$epub_opf.cover"  # Need to be same dir to $epub_opf
sed 's/</\n</g' "$epub_opf" > "$cover_opf"

id_href="$(awk '
	# Extract attribute value from a line
	# Args: line - the XML line to parse, attr - attribute name to extract
	# Returns: attribute value or empty string if not found
	function extract_attr(line, attr) {
		regex = attr \
			"[[:space:]]*=[[:space:]]*[\"'\''][^\"'\'']*[\"'\'']"
		if (match(tolower(line), tolower(regex))) {
			val = substr(line, RSTART, RLENGTH)
			# Remove attribute name and quotes
			gsub(/^[^=]*=[[:space:]]*["\047]/, "", val)
			gsub(/["\047][[:space:]]*$/, "", val)
			return val
		}
		return ""
	}
	
	BEGIN {
		meta_cover_id = ""   # ID from <meta name="cover" content="...">
		cover_found = 0	     # Flag: cover already found and printed
		candidate_id = ""    # ID of candidate cover
		candidate_href = ""  # href of candidate cover
		guide_href = ""      # href from <guide><reference type="cover">
		first_img_id = ""    # First image item id (fallback)
		first_img_href = ""  # First image item href (fallback)
	
		sp = "[[:space:]]*"
		q = "[\"\\047]"
		meta_pattern = "<meta[^>]*name" sp "=" sp q "cover" q
		reference_pattern = "<reference[^>]*type" sp "=" sp q "cover" q
	}
	
	# Process each line of the OPF file
	{
		line = $0
		line_lower = tolower(line)
		
		# 1. Search for <meta name="cover" content="...">
		if (meta_cover_id == "" && line_lower ~ meta_pattern) {
			content = extract_attr(line, "content")
			if (content != "") {
				meta_cover_id = content
			}
		}
		
		# 2. Process <item> tags in manifest
		if (line_lower ~ /<item[^>]*>/) {
			id = extract_attr(line, "id")
			href = extract_attr(line, "href")
			props = extract_attr(line, "properties")
			media = extract_attr(line, "media-type")
			
			media_lower = tolower(media)
			
			# Only process image media types
			if (media_lower ~ /^image\//) {
				
				# Store first image as fallback
				if (first_img_href == "") {
					first_img_id = id
					first_img_href = href
				}
				
				# EPUB 3: properties="cover-image"
				if (tolower(props) ~ /cover-image/) {
					print id "\t" href
					cover_found = 1
					exit
				}
				
				# Store candidate if id or href contains "cover"
				id_lower = tolower(id)
				href_lower = tolower(href)
				if ((id_lower ~ /cover/ \
						|| href_lower ~ /cover/) \
						&& candidate_href == "") {
					candidate_id = id
					candidate_href = href
				}
				
				# Match with meta cover id (EPUB 2 standard)
				if (meta_cover_id != "" \
						&& id == meta_cover_id) {
					print id "\t" href
					cover_found = 1
					exit
				}
			}
			
			# Build href->id mapping for guide reference lookup
			if (href != "") {
				href_to_id[href] = id
			}
		}
		
		# 3. Search for <reference type="cover" href="..."> in guide
		if (guide_href == "" && line_lower ~ reference_pattern) {
			h = extract_attr(line, "href")
			if (h != "") {
				guide_href = h
			}
		}
	}
	
	END {
		# Exit if cover was already found and printed
		if (cover_found) exit
		
		# Priority 1: Candidate cover (id/href contains "cover")
		if (candidate_href != "") {
			print candidate_id "\t" candidate_href
			exit
		}
		
		# Priority 2: Guide reference href
		if (guide_href != "") {
			guide_id = href_to_id[guide_href]
			# Print even if id is empty
			if (guide_id == "") guide_id = ""
			print guide_id "\t" guide_href
			exit
		}
		
		# Priority 3: First image as fallback
		if (first_img_href != "") {
			print first_img_id "\t" first_img_href
			exit
		}
		
		# No cover found
		exit 1
	}' "$cover_opf" || true)"

if ! [[ "$(echo -e "$id_href" | tr '[:upper:]' '[:lower:]')" \
		=~ \.(jpg|jpeg|png|gif|bmp|svg|webp)$ ]]; then
	href="${id_href#*$'\t'}"
	debug_var id_href
	id_href="$(find_cover_id_of_html "$cover_opf" "$href")"
	debug_var id_href

fi

rm -f "$cover_opf"

id="${id_href%%$'\t'*}"
href="${id_href#*$'\t'}"

if [[ -z "$id" || -z "$href" ]]; then
	error "$(basename "$1"): failed to find cover id"
fi

if [[ -n "$alt_cover_path" ]]; then
	image_path="$(dirname "$epub_opf")/$href"
	mkdir -p "$(dirname "$image_path")"
	cp "$alt_cover_path" "$image_path"

	change_cover_id "$id"

	format_opf > "$epub_opf"
	zip -q -Xr9D "$epub_file" "$epub_opf" "$image_path"

	log "Replaced cover image ($href) with \"$alt_cover_path\""
fi

if [[ -n "$fix_cover_given" ]]; then
	change_cover_id "$id"
	format_opf > "$epub_opf"

	# Fix incorrect cover path case (i.e., Cover.jpg -> cover.jpg)
        new_href="$(unzip -l "$epub_file" | grep -iom1 "$href")" || true
        if [[ -n "$new_href" && "$new_href" != "$href" ]]; then
                sed_i "s#$href#$new_href#" "$epub_opf"
                href="$new_href"
        fi

	zip -q -Xr9D "$epub_file" "$epub_opf"

	log "Successfully set internal image as cover: $href [$id]"
fi

if [[ -n "$out_cover_path" ]]; then
	image_path="$(dirname "$epub_opf")/$href"
	# './aa/x/y/../../z' -> 'aa/z'
	image_path="$(echo "$image_path" \
		| sed -E '
		s#^\./##
		s#/\./#/#
		:a
		s#/[^/]+/\.\./#/#g
		ta')"
	new_ext="$(echo "${image_path##*.}" | tr '[:upper:]' '[:lower:]')"

	unzip -q "$epub_file" "$image_path"
	cp -i "$image_path" "$out_cover_path.$new_ext" && \
		log "Copied cover image ($href) to \"$out_cover_path.$new_ext\""
fi
