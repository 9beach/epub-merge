#!/bin/bash

set -euo pipefail

readonly DEBUG=${DEBUG:-}  # Debug output toggle.

quiet_mode=""              # Suppress non-critical logs.
edit_mode=false            # If false, show metadata; if true, modify.
epub_file=""               # Input EPUB file path.
opf_file=""                # Input OPF file path (if given).
epub_opf=""                # Path to OPF inside EPUB.
temp_dir=""                # Temporary working directory.
indent=""                  # Indentation detected before </metadata>.
opf_filter=""              # Regex to remove old tags before insertion.
output_filter=""           # Regex for highlighting changed fields in output.
readonly real_lf=$'\037'   # Internal field separator for XML line handling.

readonly removing="<removed>"       # Marker for deleting a field.
readonly opf_header="header"        # Original OPF header path
readonly new_opf_header="newhdr"    # Modified OPF header path
readonly opf_footer="footer"        # OPF footer path

# --- From args

new_title=""
new_author=""
new_translator=""
new_publisher=""
new_subject=""
new_language=""
new_description=""
new_isbn=""
new_rights=""
new_published=""
new_modified=""

# --- Label translations

LANG_IS_KR="$(defaults read -g AppleLanguages 2> /dev/null \
	| grep 'ko-' || true)" # Just my preference

if [[ "${LANG:-ko_KR}" == ko* || -n "$LANG_IS_KR" ]]; then
	readonly label_title="제목"
	readonly label_author="작가"
	readonly label_translator="번역"
	readonly label_subject="주제"
	readonly label_publisher="출판사"
	readonly label_language="언어"
	readonly label_description="설명"
	readonly label_published="출판일"
	readonly label_modified="수정일"
	readonly label_rights="권리"
	readonly label_isbn="도서번호"
else
	readonly label_title="Title"
	readonly label_author="Author"
	readonly label_translator="Translator"
	readonly label_subject="Subject"
	readonly label_publisher="Publisher"
	readonly label_language="Language"
	readonly label_description="Description"
	readonly label_published="Published"
	readonly label_modified="Modified"
	readonly label_rights="Rights"
	readonly label_isbn="ISBN"
fi

# --- Utility functions

show_usage() {
	# Print usage and help message to stderr.
	cat >&2 << 'EOF'
epub-meta -- read and edit metadata in an ePUB or OPF file

Usage:
  epub-meta [-q] [-t title] [-a author] [-r translator] [-x rights] [-i ISBN]
            [-s subject] [-l language] [-d description] [-p publisher]
            [-u published] [-m modified] {epub-file | opf-file}

Options:
  -a author      Set author(s). Multiple authors are allowed, separated by "//".
                 Each author may optionally include a sort name, for example:
                 "Tom Waits--Waits, Tom//Lily Allen--Allen, Lily//Beck".
  -d description Set description (supports CDATA).
  -i ISBN        Set ISBN.
  -l language    Set language (e.g., en, ko).
  -m modified    Set modification date.
  -p publisher   Set publisher.
  -q             Quiet mode, suppress progress messages.
  -r translator  Set translator(s) (same format as -a).
  -s subject     Set subject(s) (multiple separated by '//').
  -t title       Set title.
  -u published   Set publication date (e.g., "2016-07-31").
  -x rights      Set rights/copyright info.
  -h             Show this help message.

Notes:
  - Use empty string ("") to remove a metadata field.
  - Without options, displays current metadata.
EOF
	exit 1
}

cleanup() {
	# Remove temporary working directory if it exists.
	if [[ -d "${temp_dir:-}" ]]; then
		rm -rf "$temp_dir"
	fi
}

log() {
	# Print gray log messages unless quiet_mode is set.
	if [[ -z "$quiet_mode" ]]; then
		printf '\033[90m%s\033[0m\n' "$*" >&2
	fi
}

debug() {
	# Print blue debug messages when DEBUG is enabled.
	if [[ -n "$DEBUG" ]]; then
		printf "\033[34m[DEBUG] #${BASH_LINENO[1]} %s\033[0m\n" "$*" >&2
	fi
}

debug_var() {
	# Print blue debug messages of a variable when DEBUG is enabled.
	# e.g., debug_var variable_name_without_dollar_prefix
	debug "$1=\"${!1}\""
}

error() {
	# Print red error message and exit.
	printf "\033[31mError (epub-merge): %s\033[0m\n" "$*" >&2
	exit 1
}

check_file_type() {
	# Quickly checks file type (XML or ZIP) by examining the first few 
	# bytes.
	local file="$1" header_bytes
	readonly zip_magic=$'PK\x03\x04' 
	readonly xml_start='<?xml'
	header_bytes=$(head -c 4 "$1")

	if [[ "$header_bytes" == "$zip_magic" ]]; then
		epub_file="$(realpath "$1")"
		readonly epub_file
		return 0
	fi

	header_bytes=$(head -c 10 "$file")
	if [[ "$header_bytes" == "$xml_start"* ]]; then
		opf_file="$(realpath "$1")"
		readonly opf_file
		return 0
	fi

	error "$(basename "$1"): not an EPUB or OPF file"
}

# --- XML handling helpers

escape_xml() {
	# Escape special XML characters and control chars.
	# If input contains CDATA, keep it intact but flatten newlines to '\r'.
	input="$1"

	# If CDATA, return as-is
	local cdata_pattern='<!\[CDATA\['
	if [[ "$input" =~ $cdata_pattern ]]; then
		# Make CDATA one line, later recover with `tr '\r' '\n'`
		printf '%s' "$input" | tr '\n' '\r'
		return
	fi

	# Otherwise, escape XML special chars and control characters
	printf '%s' "$input" \
		| tr '\n' '\r' \
		| sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' \
			-e 's/"/\&quot;/g' -e "s/'/\\&apos;/g" -e 's/#/\#/g'
		# `#` is delimeter of `sed` in the code.
}

unescape_xml() {
	sed -E -e 's/&#xD;//g' -e 's/&#13;//g' -e 's/&#xA;/\n/g' \
		-e 's/&#10;/\n/g' -e 's/&#x9;/\t/g' -e 's/&#9;/\t/g' \
		-e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&quot;/"/g' \
		-e 's/&nbsp;/ /g' -e "s/&apos;/'/g" -e 's/&#39;/'"'"'/g' \
		-e 's/&#x27;/'"'"'/g' -e 's/&amp;/\&/g'
}

join_lines() {
	# Replace '\n' with unit separator for line-safe processing.
	tr '\n' $real_lf < "${1:-/dev/stdin}"
}

split_lines() {
	# Restore line structure: '\r' and '\037' → '\n\n'.
	tr '\r'$real_lf '\n' < "${1:-/dev/stdin}"
}

split_xml_elements() {
	# Convert self-closing <dc:*> tags to open-close, and place each 
	# element (open/close) on its own line.
	tr '\n' $real_lf | sed -E "$sed_split_xml_elements"
}

sed_split_xml_elements=$(cat << 'EOF'
s#<dc:(title|publisher|subject|creator|description|rights|language\
|contributor|date|identifier)(/>|[[:blank:]]+[^>]*/>)#<dc:\1\2></dc:\1>#g;
s#(</dc:title[^>]*>|</dc:publisher[^>]*>|</dc:subject[^>]*>|</dc:creator[^>]*>\
|</dc:description[^>]*>|</dc:rights[^>]*>|</dc:language[^>]*>\
|</dc:contributor[^>]*>|</dc:identifier[^>]*>|</dc:date[^>]*>)#&\n#g;
s#(<dc:title[^>]*>|<dc:publisher[^>]*>|<dc:subject[^>]*>|<dc:creator[^>]*>\
|<dc:description[^>]*>|<dc:rights[^>]*>|<dc:language[^>]*>\
|<dc:contributor[^>]*>|<dc:identifier[^>]*>|<dc:date[^>]*>)#\n&#g
EOF
)
readonly sed_split_xml_elements

# --- Metadata display

show_tags() {
	# Parse OPF XML and output readable metadata (title, author, etc.)
	# Supports Korean or English labels. Filters and cleans XML tags.
	sed -nE "$sed_show_tags" ${1:+"$1"} \
		| grep -v "^[[:space:]]*<dc:.*" \
		| sort -V \
		| sed -E "s#</dc:.*##; s#^..##; s:^(.*) \[Unknown\]$:\1:" \
		| unescape_xml
}

# --- Metadata edit

echo_tags() {
	# Create multi tags from 'display_name--sort_name' format and 
	# multi-entry (// separated).
	local new_content="$1"
	local tags=""
	local content_lines
	content_lines=$(echo -E "$new_content" \
		| sed -E 's#[[:space:]]*//[[:space:]]*#\n#g')

	while IFS= read -r name; do
		if [[ "$name" == *'--'* ]]; then
			display_name="${name%%--*}"
			sort_name="${name##*--}"

			tags+="${real_lf}$indent$indent\n<${element}"
			tags+="${attr_string} opf:file-as=\"$sort_name\">"
			tags+="$display_name</$element>${real_lf}"
		else
			tags+="${real_lf}$indent$indent\n<${element}"
			tags+="${attr_string}>$name</$element>${real_lf}"
		fi
	done <<< "$content_lines"

	echo -e "${tags}"
}

make_new_tags() {
	# Create dc elements and print them.
	local element="dc:$1" tag
	local attr="${2:-}" value="${3:-}"
	local content="new_${4:-$1}"
	local attr_string="" new_content="${!content}"

	if [[ -z "${new_content}" || "$new_content" == "$removing" ]]; then
		return 0
	fi

	[[ -n "$attr" && -n "$value" ]] && attr_string=" ${attr}=\"${value}\""
	[[ "$new_content" == "$removing" ]] && return

	new_content="$(escape_xml "$new_content")"
	if [[ -n "${SUPPORT_MULTI_VALUES:-}" ]]; then
		echo_tags "$new_content"
	else
		tag="${real_lf}$indent$indent\n<${element}${attr_string}>"
		tag+="${new_content}</${element}>${real_lf}"
		echo -e "$tag"
	fi
}

format_opf() {
	# Rebuild the final OPF file:
	#   - combine modified header and untouched footer,
	#   - normalize line breaks,
	#   - strip blank lines.
	cat "$new_opf_header" "$opf_footer" | tr -d '\n' | split_lines \
		| grep -v '^[[:blank:]]*$' | tr '\r' '\n'
}

add_filters() {
	# Build filters for colorizing modified attributes and removing 
	# old values
	local element="$1" content="new_${4:-$1}"
	local new_content="${!content}" label="label_${4:-$1}"
	local attr="${2:-}" value="${3:-}" value_esc

	if [[ -n "$new_content" ]]; then
		# Build regex pattern for matching dc:* element with 
		# optional attribute
		local attr_pattern=""
		if [[ -n "$attr" && -n "$value" ]]; then
			value_esc=$(printf '%s' "$value" \
				| sed 's/["\]/\\&/g')
			attr_pattern="[^>]*${attr}=[\"']${value_esc}[\"']"
		fi

		opf_filter+="<dc:${element}${attr_pattern}[^>]*>|"
		output_filter+="^${!label}:.*|"
	fi
}

build_modifying_filters() {
	# These are used to remove specific XML elements and format output 
	# messages.
	#
	# Example opf_filter: "<dc:publisher[^>]*>|<dc:subject[^>]*>"
	# Example output_filter: "Publisher:.*|Subject:.*|Title:.*"
	add_filters title
	if [[ -n "$new_author" ]]; then
		opf_filter+="<dc:creator[[:space:]]*>|"
	fi
	add_filters creator opf:role aut author
	add_filters creator opf:role trl translator
	add_filters translator opf:role trl translator
	add_filters publisher
	add_filters subject
	add_filters language
	add_filters description
	add_filters identifier opf:scheme ISBN isbn
	add_filters rights
	if [[ -n "$new_published" ]]; then
		opf_filter+="<dc:date[[:space:]]*>|"
	fi
	add_filters date opf:event publication published
	add_filters date opf:event modification modified

	opf_filter="${opf_filter%?}"
	output_filter="${output_filter%?}"
}

# --- Start main routine

trap 'printf "\033[31mError ($(basename "$0")): at line $LINENO\033[0m\n" >&2; \
	cleanup' ERR INT TERM
trap cleanup EXIT

while getopts "t:a:r:p:s:l:d:i:x:u:m:qh" opt; do
	# shellcheck disable=SC2034
	case $opt in
		t) new_title="${OPTARG:-$removing}"; edit_mode=true ;;
		a) new_author="${OPTARG:-$removing}"; edit_mode=true ;;
		r) new_translator="${OPTARG:-$removing}"; edit_mode=true ;;
		p) new_publisher="${OPTARG:-$removing}"; edit_mode=true ;;
		s) new_subject="${OPTARG:-$removing}"; edit_mode=true ;;
		l) new_language="${OPTARG:-$removing}"; edit_mode=true ;;
		d) new_description="${OPTARG:-$removing}"; edit_mode=true ;;
		i) new_isbn="${OPTARG:-$removing}"; edit_mode=true ;;
		x) new_rights="${OPTARG:-$removing}"; edit_mode=true ;;
		u) new_published="${OPTARG:-$removing}"; edit_mode=true ;;
		m) new_modified="${OPTARG:-$removing}"; edit_mode=true ;;
		q) quiet_mode=1 ;;
		h) show_usage ;;
		\?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
		:) echo "Option -$OPTARG requires an argument." >&2; exit 1 ;;
	esac
done

shift $((OPTIND-1))

if [[ $# -ne 1 ]]; then
	show_usage
fi

check_file_type "$1"

if [[ -n "$epub_file" ]]; then
	epub_opf="$(unzip -p "$epub_file" META-INF/container.xml \
		| sed -n "s#.*full-path=.\([^\"']*\).*#\\1#p")"

	if [[ -z "$epub_opf" ]]; then
		error "OPF file not found."
	fi
fi

# --- Read metadata

# Parse OPF XML and output readable metadata (title, author, etc.).
readonly r_matching="(.*)(</dc:.*)"
readonly sed_show_tags="
/(<dc:title|<dc:publisher|<dc:subject|<dc:creator|<dc:description|<dc:rights\
|<dc:language|<dc:date|<dc:contributor.*[\"']trl[\"']\
|opf:scheme=[\"']ISBN[\"'])[^>]*>.+<\\/dc:/I {
s#(<dc:title[^>]*>)${r_matching}#01${label_title}: \\2#
s#(<[^>]*opf:role=[\"']trl[\"'][^>]*>)${r_matching}#06${label_translator}: \\2#
s#(<dc:subject[^>]*>)${r_matching}#08${label_subject}: \\2#
s#(<dc:description[^>]*>)${r_matching}#09${label_description}: \\2#
s#(<dc:publisher[^>]*>)${r_matching}#10${label_publisher}: \\2#
s#(<dc:date[^>]*publication[^>]*>)${r_matching}#12${label_published}: \\2#
s#(<dc:date[^>]*modification[^>]*>)${r_matching}#13${label_modified}: \\2#
s#(<dc:date[^>]*>)${r_matching}#12${label_published}: \\2#
s#(<dc:language[^>]*>)${r_matching}#25${label_language}: \\2#
s#(<dc:rights[^>]*>)${r_matching}#27${label_rights}: \\2#
s#(<[^>]*opf:scheme=.ISBN[^>]*>)${r_matching}#28${label_isbn}: \\2#
s#<[^>]*opf:role=[\"']trl[\"'][^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*>\
${r_matching}#06${label_translator}: \\2 [\\1]#
s#<[^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*opf:role=[\"']trl[\"'][^>]*[^>]*>\
${r_matching}#06${label_translator}: \\2 [\\1]#
s#<[^>]*opf:role=[\"']aut[\"'][^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*>\
${r_matching}#05${label_author}: \\2 [\\1]#
s#<[^>]*opf:file-as=[\"']([^\"']+)[\"'][^>]*opf:role=[\"']aut[\"'][^>]*[^>]*>\
${r_matching}#05${label_author}: \\2 [\\1]#
s#(<dc:creator[^>]*>)${r_matching}#05${label_author}: \\2#
p
}
"

if [[ "$edit_mode" == false ]]; then
	# No edit option, then read metadata and exit.
	if [[ -z "$opf_file" ]]; then
		unzip -p "$epub_file" "$epub_opf"
	else
		cat "$opf_file"
	fi \
	| split_xml_elements | show_tags | split_lines
	exit 0
fi

# --- Edit metadata

build_modifying_filters

temp_dir=$(mktemp -d)
readonly temp_dir

cd "$temp_dir"

if [[ -n "$opf_file" ]]; then
	epub_opf="$temp_dir/.opf"
	join_lines "$opf_file" > "$epub_opf"
else
	mkdir -p "$(dirname "$epub_opf")"
	# shellcheck disable=SC2094
	unzip -p "$epub_file" "$epub_opf" | join_lines > "$epub_opf"
fi

indent="$(grep -m 1 -o "[[:blank:]]*</metadata>" "$epub_opf" \
	| sed -E "s#</metadata>##")"
readonly indent

# Before </metadata>: <?xml... -> $opf_header
sed -E "s|(^.*)([[:blank:]]*</metadata>.*$)|\1|" "$epub_opf" \
	| split_xml_elements \
	> "$opf_header"

# From </metadata>: </metadata>...</package> -> $opf_footer
sed -E "s|(^.*)(</metadata>.*$)|${real_lf}${indent}\2|" "$epub_opf" \
	> "$opf_footer"

{
	# Remove elements to be replaced
	grep -E -v "$opf_filter" "$opf_header"

	# Print new elements
	make_new_tags title
	SUPPORT_MULTI_VALUES=1 make_new_tags creator opf:role aut author 
	SUPPORT_MULTI_VALUES=1 make_new_tags creator opf:role trl translator 
	SUPPORT_MULTI_VALUES=1 make_new_tags subject subject
	make_new_tags publisher
	make_new_tags date opf:event publication published 
	make_new_tags date opf:event modification modified 
	make_new_tags rights
	make_new_tags identifier opf:scheme ISBN isbn 
	make_new_tags description
	make_new_tags language
} > "$new_opf_header"

if [[ -z "$opf_file" ]]; then
	format_opf > "$epub_opf"
	zip -q "$epub_file" "$epub_opf"
else
	format_opf > "$opf_file"
fi

if [[ "$quiet_mode" -ne 1 ]]; then
	show_tags "$new_opf_header" \
		| sed -E "s/$output_filter/\x1b[32m&\x1b[0m/g" \
		| split_lines >&2
fi
